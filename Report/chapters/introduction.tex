\chapter{Introduction}

\epigraph{Algorithms are the computational content of Proofs.}{\textit{Robert Harper, Benjamin C. Pierce \\ Software Foundations}}

With more and more tasks in our day to day life getting automated through software, we have felt a convenience like never before. That software has helped reduce human burden in terms of computation is a trivial observation. However, on deeper inspection, one can see that computer programming has offered a useful abstraction viz. letting humans focus only on developing algorithms for computation and leave out the actual computations inessential to this process, for the computer. In essence, it has decoupled the issues of creative thinking and efficiency. There is no reason why you cannot take this abstraction to a higher level, that of automating meta-computation i.e. the process of generating computer programs. This is the central issue of \emph{Program Synthesis}. Program synthesis \footnote{adopted partly from http://research.microsoft.com/en-us/um/people/sumitg/pubs/synthesis.html} is the task of automatically discovering an executable piece of code given user intent expressed using various forms of constraints such as input-output examples, demonstrations, natural language, etc.

\section{Motivation}
Some traditional issues \cite{kreitz1998program} we have been facing for decades in the field of software production are the cost of non-standard software, due to long development times and the constant need for maintenance, and a lack of confidence in the reliability of software. Accidents like the crash of KAL's 747 in August 1997, the Therac-25 medical radiation therapy device's over-dosage error in 2000, etc are some examples of software errors causing serious repercussions. Program synthesis offers a solution to the above issues by automating much of the mundane parts of code generation and also establishing correctness of these programs through \emph{Formal Verification} techniques. Though these issues persist to be the main driving force of program synthesis, the spectrum of benefits it offers has broadened over time. Here are some ways in which program synthesis holds direct applications for various classes of users in the technology pyramid :
\begin{itemize}
\item (100s of millions of) End Users (people who have access to a computational device but are not expert programmers): Helping them to create small snippets of code for performing repetitive tasks, simple data manipulation. In other words, enabling them to bring their creativity to life!
\item (Billions of) Students and Teachers: Intelligent tutoring systems that support solution generation (the step-by-step solution to a problem is like a program! PLDI 2011\cite{gulwani2011synthesizing}, IJCAI 2013b\cite{ahmed2013automatically}), problem generation (of a certain difficulty level and that exercises use of certain concepts AAAI 2014\cite{alvin2014synthesis}, IJCAI 2013b\cite{ahmed2013automatically}), automated grading (PLDI 2013 \cite{singh2013automated}) , and digital content creation (CHI 2012 \cite{cheema2012quickdraw}). Interestingly, all of these activities can be phrased as program synthesis problems.
\item Software Developers: Help synthesize mundane pieces of code.
\item Algorithm Designers: Help discover new algorithms.
\end{itemize}

\section{Outline}
We move ahead with the discussion on program synthesis in chapter 2, where we would be illustrating it using examples. Then we briefly see various dimensions along which program synthesis can be performed. Later in the chapter we explain why functional programming is a lucrative platform for program synthesis and the benefits it holds in comparison with imperative programming. In chapter 3, we study the features of Coq, an interactive theorem prover based on functional programming, that make it particularly useful for program synthesis. In chapter 4, we discuss about the problem of higher order unification, and a restricted yet powerful version of the unification problem that Ankit has implemented in Coq. Later in chapter 5, we study the problem of finding the ``longest prefix of a list satisfying p'' problem. There we go through parts of a previous derivation by Ankit, for solving the problem in linear time. We suggest a way involving input-output examples that helps assist/automate parts of the derivation which would otherwise require human insights. We then briefly discuss the benefits of the proposed approach over $Igor2$, a pure inductive synthesis algorithm. In chapter 6, we conclude by summarizing the entire work and laying out future goals.