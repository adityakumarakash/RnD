\chapter{Background}

As we have seen, Program Synthesis is the task of discovering an executable piece of code from user intent given a high level specification of the goal. As we shall see later, this high level specification can take different forms and in fact this becomes a dimension \cite{gulwani2010dimensions} along which program synthesis can be classified. For now, let us understand program synthesis through an example.

\section{An Example of Program Synthesis}
Below is a toy example \footnote{adopted from \url{https://en.wikipedia.org/wiki/Program_synthesis}}, of derivation of a functional program to compute the maximum M of two numbers x and y. \\

\begin{table}[h!]
\centering
\label{max_synthesis_axioms}
\begin{tabular}{|l|l|l|}
\hline
No. & Assertions     			& Origin 		\\ \hline
1   & $A = A$        			& Axiom     	\\
2   & $A \leq A$				& Axiom     	\\
3   & $A \leq B \vee B \leq A$ 	& Axiom     	\\ \hline
\end{tabular}
\caption{Some basic axioms related to comparison}
\end{table}

\noindent
To begin with, we consider the assertions mentioned in table 2.1 as our axioms. As you can see, these axioms are very basic and just state the laws of trichotomy. However, we make use of these to derive a functional program that computes the maximum of two numbers; something that is non-trivial to obtain from just these axioms (at least for a computer). \\

\begin{table}[h!]
\centering
\label{max_synthesis}
\begin{adjustwidth}{-0.6cm}{}
\begin{tabular}{|l|l|l|l|}
\hline
No. & Goal & Program & Origin \\ \hline
10  & $x \leq M \wedge y \leq M \wedge (x = M \vee y = M)$ & $M$ & Specification\\
11  & $(x \leq M \wedge y \leq M \wedge x = M) \vee (x \leq M \wedge y \leq M \wedge y = M)$ &    $M$     		& Distr(10)  	\\
12  & $x \leq M \wedge y \leq M \wedge x = M$ & $M$ & Split(11) \\
13  & $x \leq M \wedge y \leq M \wedge y = M$ & $M$ & Split(11) \\
14  & $x \leq x \wedge y \leq x$ & $x$ & Resolve(12,1) \\
15  & $y \leq x$ & $x$ & Resolve(14,2) \\
16  & $\neg (x \leq y)$ & $x$ & Resolve(15,3) \\
17  & $x \leq y \wedge y \leq y$ & $y$ & Resolve(13,1) \\
18  & $x \leq y$ & $y$ & Resolve(17,2) \\
19  & $true$ & $x \leq y ? y : x$ & Resolve(18,16) \\ \hline
\end{tabular}
\end{adjustwidth}
\caption{Example synthesis of maximum function using the axioms in table 2.1}
\end{table}

\noindent
Starting from the requirement description ``The maximum is larger than any given number, and is one of the given numbers'', the first-order formula $\forall X \forall Y \exists M : X \leq M \wedge Y \leq M \wedge (X = M \vee Y = M)$ is obtained as its formal translation. This formula is to be proved. By reverse Skolemization, the specification in line 10 (in table 2.2) is obtained, an upper- and lower-case letter denoting a variable and a Skolem constant, respectively. After applying the distributive law in line 11, the proof goal is a disjunction, and hence can be split into two cases, viz. lines 12 and 13. Turning to the first case, resolving line 12 with the axiom in line 1 leads to instantiation of the program variable M in line 14. Intuitively, the last conjunct of line 12 prescribes the value that M must take in this case. Formally, this conjunct unifies syntactically with the axiom on line 1 by substituting $x$ for $M$ as well as $A$. On making this substitution throughout our goal in line 12, we reach the goal in line 14, the first conjunct of which is trivially true through the axiom in line 2. Thus for the case of $\neg (x \leq y)$, we obtained the program to be $x$. A similar reasoning for the goal in line 13 leads us to the program $y$ for the case of $x \leq y$. We combine both these goals to obtain a goal in line 19 which is $true$ always. The program corresponding to this line is the one we aimed to compute.

\section {A Different Example of Program Synthesis}
In the above example, we have seen the computation of a program starting from a specification that is essentially a logical representation of our goal. It relates logically, the input and output of our program. Though logical representations present a succinct way to provide a formal specification of our desired program, they are often difficult to obtain and use in practice. On the contrary, having an inefficient program to begin with, is often quite useful as we have a correct and working program at the very start. This can continuously be written into a more and more efficient program through calculation rules, such that the correctness in preserved at each step. Both these methods of problem specification are only different ways of conveying user intent. We discuss this in detail in the next section. \\\\
Let us now look at the following example of program derivation, where we want to obtain a program for calculating the minimum element among a list of integers. Consider the following functional specification for doing the same. \\\\

\begin{align*}
minimum &=\: head\: \circ\: sort \\
sort [] &=\: [] \\
sort (x : xs) &=\: insert\: x\: (sort\: xs) \\
insert\: a\: [] &=\: [a] \\
insert\: a\: xs &=\: if\: (a\: <\: head\: xs)\: then\: (a\: :\: xs)\: else\: (head\: xs)\: :\: (insert\: a\: (tail\: xs)) \\
head\: (x\: :\: xs) &=\: x
\end{align*}

\noindent
We derive a recursive definition of minimum from the above specification, by inducting on the input list.

\vspace{0.5em}
\begin{equation*}
\begin{split}
minimum\: [x] &= head(sort\: [x]) \\\\
&= \{\bf{unfolding}\: sort\} \\ &\quad \; head\: (insert\: x\: (sort\: [])) \\\\
&= \{\bf{definition\: of}\: sort\} \\ &\quad \; head\: (insert\: x\: []) \\\\
&= \{\bf{definition\: of}\: insert\} \\ &\quad \; head\: [x] \\\\
&= \{\bf{definition\: of}\: head\} \\ &\quad \; x
\end{split}
\end{equation*}

\vspace{1em}
\begin{align*}
minimum\: (x\: :\: xs)
            &= head\: (sort\: (x\: :\: xs)) \\\\
 			&= \{\bf{unfolding}\: sort\} \\
 			   &\quad \; head\: (insert\: x\: (sort\: xs)) \\\\
 			&= \{\bf{unfolding}\: insert\} \\
 			   &\quad \; head\: (if\: (x < head\: (sort\: xs))\: then\: x\: :\: (sort\: xs) \\
 			   &\quad \quad \quad \quad else\: (head\: (sort\: xs))\: :\: (insert\: x\: (tail\: (sort\: xs))) \\\\
 			&= \{\bf{if\: promotion\: rule}\: :\: f(if\: e_1\: then\: e_2\: else\: e_3)\: =\\
 			   &\qquad \qquad \qquad \bf{if}\: e_1\: then\: (f\: e_2)\: else\: (f\: e_3)\} \\
 			   &\quad \; if\: (x < head(sort\: xs))\: then\: head(x\: :\: (sort\: xs)) \\
 			   &\quad \; else\: head\: (head\: (sort\: xs)\: :\: insert\: x\: (tail\: (sort\: xs))) \\\\
 			&= \{\bf{definition\: of\: head}\} \\
 			   &\quad \; if\: (x < head(sort\: xs))\: then\: x\: else\: head(sort\: xs) \\\\
 			&= \{\bf{abstracting\: out\: head(sort\: xs)\: and\: folding\: back\: minimum}\} \\
 			   &\quad \; if\: (x < y)\: then\: x\: else\: y\\
 			   &\quad \quad \quad where\: y = minimum\: xs
\end{align*}

\section{Dimensions of Program Synthesis}
We know that compilers and assemblers mostly translate a program written in a structured high-level language into a low-level or machine language in a syntax-directed fashion. While on the other hand, program synthesizers take as input the user intent through a variety of constraints such as logical relations between inputs and outputs, partial or inefficient programs, natural language, input-output examples, etc. Then they process these constraints and come up with an output program after searching through a space of programs. In this section, we briefly describe the dimensions along which program synthesizers may be classified, partly in accordance to Sumit Gulwani \cite{gulwani2010dimensions}, excerpts from which have been adopted here.

\subsection{Input Specification}
One of the most important aspects of program synthesis from the user's perspective is the mechanism to specify his intent. As we see below, some of the main choices possible for this are logical specifications, natural language specifications, input-output examples and higher-order, inefficient or partial programs. Depending on the user's skill and the task underlying, a particular choice of the specification may be more suited.

\subsubsection{Logical Specifications}
A  logical  specification is a logical relation between inputs and outputs of a program. It can act as a precise and succinct form of functional specification of the desired program. For example, the logical specification for a program that finds out the maximum of two numbers $x$ and $y$ as $M$ is as follows (recall from the example in section 2.1): \\\\
$x \leq M \wedge y \leq M \wedge (x = M \vee y = M)$ \\\\
Clearly the above logical expression relates the inputs and the output and has to hold for any program that computes the maximum correctly. It merely states that the maximum must be greater than or equal to both the numbers and should be equal to one of them. As you can see, this is only a specification of our end goal and it says nothing about how we arrive at a program which satisfies it. \\\\
As another example, consider any sorting algorithm for a list of numbers. The logical specification for the sorted list $S$ of a given list $L$ of size $n$ would assert that $S$ is a \emph{permutation} of the list $L$ and has its elements \emph{sorted}. \\\\
Though synthesis systems that accept user intent in the form of logical specifications exist, compared to other forms of specifications such as input-output examples and partial/inefficient programs, logical relations require additional knowledge of logic. Further they might be harder to get right, and may not be a preferred form of specification for end-users.

\subsubsection{Input-Output Examples}
In several scenarios, input-output examples can act as the simplest form of specification, with relatively little chances of error. Quite contrary to what it may seem initially, input-output examples, in conjunction with interactive rounds, can often play the role of a full functional specification. \\\\
It is natural to ask what prevents the synthesizer from synthesizing a trivial program that simply performs a table lookup as follows, when provided with the set $\{(x_1,y_1), (x_2,y_2),..., (x_n,y_n)\}$ of input-output pairs. \\
\begin{lstlisting}
switch x
	case x_1: return y_1;
	case x_2: return y_2;
		.
		.
		.
	case x_n: return y_n;
\end{lstlisting}
We can defend ourselves from obtaining such trivial solutions by restricting the search space of our function. In particular, we could allow only for a bounded number of statements or conditionals. Another concern with input-output examples is the selection criterion and the number of input-output examples. In other words, identifying what constitutes a good input-output example, and how many examples should the user provide? The user may start by providing few input-output examples (possibly a couple of examples for each of the corner cases) and then add more input-output examples in each interactive round. The interaction may either be driven by the user or by the synthesizer, briefly described below. \\\\
\textbf{User Driven Interaction} The user inspects the program returned by the synthesizer, studies/tests it to find any discrepancy in the behaviour of the program and the expected behaviour on a new input. If so, the user repeats the synthesis process after adding the new input-output pair to the list of input-output examples. \\\\
\textbf{Synthesizer Driven Interaction} Given a set of input-output pairs, the synthesizer searches for programs that map each input in the given set to the corresponding output. Assuming that the search space is restricted, there would only be a few satisfying programs. If the synthesizer finds at least two satisfying programs $P_1$ and $P_2$, it declares the user specification to be partial. In such a case, it generates a \emph{distinguishing input}, on which both programs generate different outputs, and presents it to the user asking for its corresponding output. The synthesis process is then repeated with this input-output pair added to the previous examples.\\\\
This type of synthesis, where search for programs is driven by input-output examples is known as \emph{Inductive Synthesis}. This is the subject of Emmanuel Kitzelmann's thesis \cite{kitzelmann2011combined}, where he describes an algorithm \emph{Igor2} that combines analytical and search-based approaches for inductive synthesis. We discuss about it briefly in chapter 5.

\subsubsection{Programs}
Programmers might sometimes find a programming language as the best means of specifying their intent. Even for applications such as discovery of new algorithms, some people might find it easier to write the specification as an inefficient program rather than a logical relation. We have seen an example of this in section 2.2, where our initial function for finding the minimum of a list of numbers merely picked the head of the list after sorting. Clearly the sorting function used there would take time $O(n^2)$ where $n$ is the size of the input list. This is also the time complexity for the initial algorithm. However, through equational rewriting and unfolding, we derive an efficient program that takes only $O(n)$ time.

\subsubsection{Natural Language}
Given advances in natural language processing, it is possible to map
natural language sentences into logical representations \cite{zettlemoyer2009learning}. Natural language can be used as a substitute for logical relations, and end-users might find it very valuable. In particular, natural language interfaces have been designed to query databases to accommodate the need of end-users who interact with databases, but are intimated by the idea of using languages such as SQL. Infact, I myself have worked before on such a project for translating queries from english to SQL given the underlying database schema. There I tried to perform this translation through a deterministic method involving \emph{Context Free Grammars} (CFGs) as well as statistically through a \emph{Machine Translation} system called \emph{Moses}. Here is a link to the project repository \url{https://github.com/shyamjvs/cs626_project}. \\\\
However, the disadvantage with natural language is that it can be ambiguous. More over, from the point of program synthesis, we are not very much interested in this form of user intent as eventually natural language must be converted to a structured (possibly logical) representation for a machine to work with. Thus we choose to neglect natural language inputs, thinking of them as more of the \emph{Machine Translator}'s and \emph{Natural Language Processor}'s job rather than the \emph{Program Synthesizer}'s job.

\subsection{Search Space}
The second dimension in program synthesis is the space of programs over which the desired program will be searched. This choice is made by the developer of the synthesizer and may optionally be restricted by the user of the synthesizer. \\\\
The developer of the synthesizer needs to strike a good balance between expressiveness and efficiency of the search space. On one hand, the space of the programs should be large/expressive enough to include programs that users care about. While on the other hand, the space of the programs should be restrictive enough so that it is amenable to efficient search, and it should be over a domain of programs that are amenable to efficient reasoning. \\\\
The user of the synthesizer can optionally restrict the search space to obtain programs with specific resource usage. For example, the user might desire a loop-free program, or a program whose memory usage does not exceed a specified amount. \\\\
Broadly speaking, the search space can be over the space of (Turing-complete) programs, or restricted form of computational models such as grammars and logics. For the purpose of our work, we choose to neglect computational models involving learning of grammars and logics. The key choice we decide to make is among \emph{Functional} and \emph{Imperative} programs, as these are most widely in use at present. \\\\
We choose functional programming over imperative programming due to better suitability to program synthesis and verification. The most significant differences between both stem from the fact that functional programming avoids side effects, which are used in imperative programming to implement state and I/O. Pure functional programming completely avoids side-effects and provides \emph{Referential Transparency}, which makes it easier to verify, optimize, and parallelize programs, and easier to write automated tools to perform those tasks. \\\\
Further, higher-order functions are rarely used in traditional imperative programming. Where an imperative program might use a loop to traverse a list, a functional program would use a different technique. It would use a higher-order function that takes as arguments a function and a list. The higher-order function would then apply the given function to each element of the given list and then return a new list with the results. This again is amenable to program verification, as iteration would involve state maintenance. So we achieve recursion (thus iteration) in functional programming, without losing referential transparency.