\chapter{Program Derivation in Coq}

Programming is the art of designing efficient programs that meet their specifications. There are two approaches  to it \cite{tesson2010program}. The first approach consists of constructing a program and then proving that the program meets its specification. However, the verification of a (big) program is rather difficult and often neglected by many programmers in practice. The second approach is to construct a program and its correctness proof hand in hand, therefore making a posteriori program verification unnecessary. \\\\
Program calculation, following the second approach, is a programming technique that derives programs from specifications by means of formula manipulation: calculations that lead to the program are carried out in small steps so that each individual step is easily verified. More concretely, in program calculation, specification could be a program that straightforwardly solves the problem, and it is rewritten into a more and more efficient one without changing the meaning, by application of calculation rules (theorems). If the program before transformation is correct, then the one after transformation is guaranteed to be correct, because the meaning of the program is preserved by the transformation. \\\\
In this chapter, we explore the power of Coq as a tool to support program calculation techniques. The authors of \cite{tesson2010program} were the first ones to identify Coq, which is a popular theorem prover, as a means to implement a powerful system to support program calculation. They have implemented a set of tactics for the Coq proof assistant to write proofs in calculational form. Their work is primarily directed towards developing a theory of lists, and proving it in a calculational and algebraic style.

\section{Coq: An overview}
Coq \footnote{\url{http://coq.inria.fr}} is a proof assistant which provides an interactive environment for defining objects (integers, sets, trees, functions, programs,...), making statements (using basic predicates and logical connectives), and finally writing proofs. Coq provides user-friendly features required for program derivation techniques, like defining recursive functions, term rewriting, polymorphic types, automatic simplification, etc. These features makes it an attractive tool to be used as the underlying system for developing program derivation techniques. An interesting additional feature of Coq is that it can automatically extract executable programs from specifications, as either Objective Caml or Haskell source code. \\\\
The Coq proof assistant is based on the \emph{Calculus of Inductive Constructions}(CIC) \cite{coquand1988calculus} and implements \emph{Natural Deduction logic system}. This calculus is a higher-order dependent typed $\lambda$-calculus \cite{pierce2002types}. Properties, programs and proofs are all formalized in the same language (CIC). Then, all logical judgments in Coq are typing judgments: the very heart of Coq is in fact a \emph{type-checking} algorithm.

\section{The language of Coq}
Coq objects are sorted into two categories: the $Prop$ \emph{sort} and the $Type$ \emph{sort}:
\begin{itemize}
\item $Prop$ is the sort for propositions, i.e. well-formed propositions are of type $Prop$. Typical propositions are: \\\\
\input{./code/typical_propositions.tex}
\vspace{1em}
and new predicates can be defined either inductively, e.g.: \\\\
\input{./code/even_predicate.tex}
\vspace{1em}
or by abstracting over other existing propositions, e.g.: \\\\
\input{./code/abstracting_prop.tex}
\vspace{1em}
\item $Type$ is the sort for datatypes and mathematical structures, i.e. well-formed types or structures are of type $Type$. Here is a basic example of type: \\\\
$Z \rightarrow Z * Z$ \\\\
Types can be inductive structures, e.g.: \\\\
\input{./code/inductive_types.tex}
\vspace{1em}
or types for tuples, e.g.: \\\\
\input{./code/monoid_structure.tex}
\vspace{1em}
or a form of subset types called $\sum$-types, e.g. the type of even natural numbers. \\\\
$\{n\: :\: N\: |\: even\: n\}$ \\\\
Coq implements a functional programming language supporting these types. For instance, the pairing function of type $Z \rightarrow Z * Z$ is written $fun\: x \implies (x,x)$ and $cons\: (S\: (S\: 0))\: (cons\: (S\: 0)\: nil)$ (shortened to 2::1::nil in Coq) denotes a list of type $list\: nat$ made of the two elements 2 and 1. \\\\
Using $\sum$-types, a sorting function over lists of natural numbers can be given the type: \\\\
\input{./code/sort_sigma.tex}
\vspace{1em}
where $sorted$ is a predicate that expresses that a list is sorted; and $same\_elements$ says if two lists contain the same elements. On the contrary, a sorting function in a ``poor'' type system could only be given the following less informative type: \\\\
$sort\: :\: list\: nat \rightarrow list\: nat$ \\\\
Such a type (specification) enforces the user to write the proofs of predicates $sorted\; l'$ and $same\_elements\; l\; l'$ when writing an implementation for the the function $sort$. \\\\
Then, functions over inductive types are expressed using a case analysis: \\\\
\input{./code/plus_fixpoint.tex}
\vspace{1em}
Coq can now be used as an interactive evaluator. Issuing the command \\\\
$Eval\: compute\: in\: (43+55)$ \\\\
(where 43 and 55 denote the natural numbers with respectively 43 and 55 successors) returns \\\\
98 : nat
\end{itemize}

\section{Proving in Coq}
Proof development in Coq is done through a language of tactics that allows a user-guided proof process. At the end, the curious user can check that tactics build lambda-terms. For example the tactic $intros\: n$, where $n$ is of type $nat$, builds the term (with a hole): \\\\
$fun\: (n:nat)\: =>\: \_$ \\\\
where \_ represents a term that will be constructed after, using other tactics. \\\\
Here is an example of a proof in the Coq system: \\\\
\input{./code/seq_length_proof.tex}
\vspace{1em}

\noindent
Using the Print command, the user can look at the proof-term generated using the tactics: \\\\\\
\input{./code/seq_length_proofterm.tex}

\section{Working Principles of Coq Proof System}
Theorems are types and their proofs are terms of Coq's calculus. This is based on the well known \emph{Curry-Howard isomorphism} between formal logic and typed lambda calculus. At the level of formulas and types, the correspondence says that implication ($\implies$) behaves the same as a function type, conjunction ($\wedge$) as a "product" or "pair" type, disjunction ($\vee$) as a "sum" or "union" type, the false formula as the empty type and the true formula as the singleton type (whose sole member is the null object). Quantifiers correspond to dependent function space or pairs (as appropriate). \\\\
To prove a theorem stated in formal logic, all one needs to do is to show the existance of a $\lambda$-term of type corresponding to the theorem. A type is said to be inhabited if there exists a value of that type. A type is only inhabited when it corresponds to a true theorem in mathematical logic. \\\\
As an example, consider the \emph{modus ponens} theorem : $P \implies (P \implies Q) \implies Q$. This can be proved by observing that $(\lambda\: (x\: :\: P)\: (y\: :\: P \rightarrow Q).y\: x)$ has type $P \rightarrow (P \rightarrow Q) \rightarrow Q$. Here $x$ and $y$ represent the proof terms of type $P$ and $(P \rightarrow Q)$ respectively. (Note that $P \rightarrow Q$ is a function type corresponding to the implication $P \implies Q$.) Now if we wish to prove $Q$, we just need to find and ``apply'' the proof terms for $P$ and $P \implies Q$ to the above term. \\\\
This is how Coq's proof engine works - by constructing a proof term of type corresponding to the given theorem. The Coq system helps the user to build the proof terms and offers a language of tactics to do so. To produce a proof, backward reasoning is used with tactics. A tactice transforms a goal into a set of subgoals (and hence constructing a partial proof tree) such that solving these subgoals is sufficient to solve the original goal. The proof succeeds when no subgoals are left.