\chapter{Conclusion}

Program synthesis is the task of automatically discovering an executable piece of code given user intent expressed using various forms of constraints such as input-output examples, demonstrations, natural language, etc. We have seen examples of program synthesis starting from different specifications. We have also explored the dimensions along which program synthesis may be carried out. These dimensions are primarily the way user intent is specified, the space of programs we search in and the search technique itself. \\\\
Program derivation is a different approach of programming, where we calculate the solution from the problem statement by appealing to correctness-preserving transformations. Functional programming paradigm provides a very neat and elegant platform for expressing problems and developing their solutions by manipulating the expressions using algebraic laws. \\\\
The aim is to develop an interactive system which would automate the derivation process, by heuristically applying laws and other techniques and also taking hints from the user for key steps. A system should not only have support for applying these techniques, but also have the intelligence of when/how to apply them. Some of the decisions in the derivation can be tricky and non-obvious, for which the system would rely on userâ€™s guidance. We wish to reduce such interactions and push the boundaries of capabilities of such a system as far as possible. \\\\
We have also studied Coq and found it to be lucrative to be used as the underlying tool for such a system. Its support for automatic rewriting, simplification of expressions, higher order functions, polymorphic types, proof tactics, etc is catalytic for developing program derivation strategies. One major contribution from Ankit has been the implementation of a Coq plugin for higher order unification of terms, based on de Moor and Sittampalam's algorithm, and building a database of useful functional laws for list based functions. \\\\
Following this, we studied briefly the derivation for finding the ``longest prefix which satisfies $p$'' problem by Ankit. While in his derivation, human insights and ingenuity were used to derive the sufficient conditions on $p$ for a linear time solution, we wish to synthesize even these conditions automatically. For this, we suggest that we make use of input-output examples crafted in such a way that they indicate structural relations between the answer of a larger input and the answer to a smaller input, where the smaller input is a recursive subproblem of the larger input. These insights arise from the case study of an inductive synthesis algorithm \emph{Igor2}. We see that a program derivation technique using algebraic transformation rules lacks ingenuity to introduce new propositions or rules. On the other hand, a purely inductive synthesis technique like that of \emph{Igor2} fails to take advantage of the structural relationships among the examples. In the next phase of the project, we plan to formally concretize this intuition and propose a way of assisting the user in the process of derivation. This would essentially involve suggesting propositions at points in the derivation where we are unable to move ahead.
